/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

#include <vector>
#include <string>
#include <iostream>
#include <string.h>
#include <stdlib.h>
#include <fstream>

using namespace std;

#include "CustomSamplerVoice.h"

AudioProcessor* JUCE_CALLTYPE createPluginFilter();

class FloatParameter : public AudioProcessorParameter
{
public:

    FloatParameter (float defaultParameterValue, const String& paramName)
       : defaultValue (defaultParameterValue),
         value (defaultParameterValue),
         name (paramName)
    {
    }

    float getValue() const override
    {
        return value;
    }

    void setValue (float newValue) override
    {
        value = newValue;
    }

    float getDefaultValue() const override
    {
        return defaultValue;
    }

    String getName (int maximumStringLength) const override
    {
        return name;
    }

    String getLabel() const override
    {
        return String();
    }

    float getValueForText (const String& text) const override
    {
        return text.getFloatValue();
    }

private:
    float defaultValue, value;
    String name;
};

const float defaultGain = 1.0f;
const float defaultBalance= 0.0f;
const float defaultDelay = 0.5f;


//==============================================================================
JuceDemoPluginAudioProcessor::JuceDemoPluginAudioProcessor()
    : delayBuffer (2, 12000)
{
    debugLog((String) __FUNCTION__, true );
    // Set up our parameters. The base class will delete them for us.
    addParameter (gain  = new FloatParameter (defaultGain,  "Gain"));
    addParameter (delay = new FloatParameter (defaultDelay, "Delay"));
    addParameter (balance = new FloatParameter (defaultBalance, "Balance"));

    lastUIWidth = 400;
    lastUIHeight = 200;

    lastPosInfo.resetToDefault();
    delayPosition = 0;

    this->checkPathExists(samplesPath,true);
    
    // Initialise the synth...
    int startNote= 35;
    for (int i = 16; --i >= 0;){
        synth.addVoice (new CustomSamplerVoice(this));   // These voices will play our custom sine-wave sounds..
    }
    for (int i = 0;++i < 9;){
        this->checkPathExists(samplesPath+"/"+(String)i,true);
        drumStripes.push_back(new DrumStripeHandler(this,samplesPath,i,startNote+i));
    }
    
    
//
//    synth.addSound (new SineWaveSound());
//    for (int i = 0; i < 16; ++i)
//        synth.addVoice (new CustomSamplerVoice());
//    //samplesPath ="GroovOliouRes";
//   samplesPath ="~/Library/Audio/Plug-Ins/VST/GroovOliouRes/";
//   String sampledReady = this->setSample(samplesPath+"/1/BT0AAD0.WAV", 36);
//    sampledReady = this->setSample(samplesPath+"/2/HHOD0.WAV", 37);
    //synth.noteOn(1, 36, 127);
    //AlertWindow::showMessageBox(AlertWindow::InfoIcon, "test", "test");
   // DrumStripeProcessor  *proc = new DrumStripeProcessor();
//    info = "Copy your samples under "+samplesPath +". Press Ctrl to assign control change.";

    
//    //Initialize drumstripes
//   drumStripes.push_back(new DrumStripeHandler(this,samplesPath,0,36));
//   drumStripes.push_back(new DrumStripeHandler(this,samplesPath,1,37));
//    drumStripes.push_back(new DrumStripeHandler(this,samplesPath,2,38));
}

JuceDemoPluginAudioProcessor::~JuceDemoPluginAudioProcessor()
{
}

bool JuceDemoPluginAudioProcessor::checkPathExists(String path, bool createFolder)
{
    juce::String sMyFolderPath(path);
    juce::File myFolder( sMyFolderPath );
    bool isDirectory = myFolder.isDirectory();
    if ( myFolder.isDirectory() == false and createFolder )
    {
        return myFolder.createDirectory();
    }
    return isDirectory;
}


//void JuceDemoPluginAudioProcessor::addVoices(AudioProcessorEditor* editor){
//        for (int i = 0; i < 16; ++i)
//            synth.addVoice (new CustomSamplerVoice(editor));
//}

String JuceDemoPluginAudioProcessor::setSample(String samplePath, int note)
{
    formatManager.registerBasicFormats();
    
    
    File audioFile (samplePath);
    
    // 音频文件中的数据“转交”给AudioFormatReader
    //reader = formatManager.createReaderFor (audioFile);
    ScopedPointer<AudioFormatReader> reader( formatManager.createReaderFor(audioFile));
    
    if (reader != nullptr)
    {
        BigInteger notes;
        notes.setRange (note, 1, true);
        SamplerSound::Ptr sound = new SamplerSound (samplePath, *reader, notes, note, 0.0, 0.1, 60.0);
        synth.addSound (sound);
        return "loaded";
    }else{
        return "error";
    }
}

//==============================================================================
void JuceDemoPluginAudioProcessor::prepareToPlay (double sampleRate, int /*samplesPerBlock*/)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    synth.setCurrentPlaybackSampleRate (sampleRate);
    keyboardState.reset();
    delayBuffer.clear();
    
    //info = (String) sampleRate;
    
    
    
}

void JuceDemoPluginAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
    keyboardState.reset();
}

void JuceDemoPluginAudioProcessor::reset()
{
    // Use this method as the place to clear any delay lines, buffers, etc, as it
    // means there's been a break in the audio's continuity.
    delayBuffer.clear();
}

void JuceDemoPluginAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    const int numSamples = buffer.getNumSamples();
    int channel, dp = 0;

    //rms = 1.0078;
    
    //info = drumProcessor->info;
    
    // Now pass any incoming midi messages to our keyboard state object, and let it
    // add messages to the buffer if the user is clicking on the on-screen keys
    keyboardState.processNextMidiBuffer (midiMessages, 0, numSamples, true);
    
    MidiBuffer processedMidi;
    int time;
    MidiMessage m;
    
    gainR=gain->getValue();
    gainL=gain->getValue();
    
    if(balance->getValue()>0){
        //gainR=
        gainL=gain->getValue()*(1 - balance->getValue());
    }
    if(balance->getValue()<0){
        gainR=gain->getValue()*(1 + balance->getValue());
        //gainL=
    }
    
    for (MidiBuffer::Iterator i (midiMessages); i.getNextEvent (m, time);)
    {
        if (m.isController())
        {
//            handleController (channel, m.getControllerNumber(), m.getControllerValue());
//            info = "controllerMoved2:" + (String) m.getControllerNumber();
            
            for (auto & drumStripe : drumStripes) {
                drumStripe->handleControlChange(m.getControllerNumber(), m.getControllerValue());
            }
            
        }
        else if (m.isProgramChange())
        {
//            handleProgramChange (channel, m.getProgramChangeNumber());
        }else if (m.isNoteOn()){
            for (auto & drumStripe : drumStripes) {
                drumStripe->updateNote(m.getNoteNumber());
            }
        }
    }
    
//
    // and now get the synth to process these midi events and generate its output.
    
    synth.renderNextBlock (buffer, midiMessages, 0, numSamples);
    //synth.
    
//    SamplerSound *sound = dynamic_cast<SamplerSound*>(synth.getSound(0));
//    AudioSampleBuffer *AudioData = sound->getAudioData();
//    
//    buffer.applyGain (1, 0, buffer.getNumSamples(), gainR);
//    buffer.applyGain (0, 0, buffer.getNumSamples(), gainL);
    
    
    
//    for (MidiBuffer::Iterator i (midiMessages); i.getNextEvent (m, time);)
//    {
//        if (m.isNoteOn())
//        {
//            info = (String) m.getNoteNumber();
//            if(m.getNoteNumber() == 36){
//                synth.renderNextBlock (buffer, midiMessages, 0, numSamples);
//                buffer.applyGain (1, 0, buffer.getNumSamples(), gainR);
//                buffer.applyGain (0, 0, buffer.getNumSamples(), gainL);
//            }
//            if(m.getNoteNumber() == 37){
//                synth.renderNextBlock (buffer, midiMessages, 0, numSamples);
//                //buffer.applyGain (1, 0, buffer.getNumSamples(), gainR);
//                //buffer.applyGain (0, 0, buffer.getNumSamples(), gainL);
//            }
//            
//        }
//        else if (m.isNoteOff())
//        {
//        }
//        else if (m.isAftertouch())
//        {
//        }
//        else if (m.isPitchWheel())
//        {
//        }
//    }
//    
    

}

//==============================================================================
AudioProcessorEditor* JuceDemoPluginAudioProcessor::createEditor()
{
    return new JuceDemoPluginAudioProcessorEditor (*this);
}

//==============================================================================
void JuceDemoPluginAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    debugLog((String) __FUNCTION__, true );
    // You should use this method to store your parameters in the memory block.
    // Here's an example of how you can use XML to make it easy and more robust:

    // Create an outer XML element..
    XmlElement xml ("MYPLUGINSETTINGS");

    // add some attributes to it..
    xml.setAttribute ("uiWidth", lastUIWidth);
    xml.setAttribute ("uiHeight", lastUIHeight);
    xml.setAttribute ("gain", gain->getValue());
    xml.setAttribute ("delay", delay->getValue());
    
    
    for (auto & drumStripe : drumStripes) {
        String objectName = "drumStripe" +(String)drumStripe->position +"_";
        xml.setAttribute (objectName+"samplesPath", drumStripe->samplesPath);
        xml.setAttribute (objectName+"soundIndex", drumStripe->soundIndex);
        xml.setAttribute (objectName+"forcedSoundIndex", drumStripe->soundIndex);
        xml.setAttribute (objectName+"playMode", drumStripe->playMode);
        xml.setAttribute (objectName+"reverse", drumStripe->reverse);
        xml.setAttribute (objectName+"note", drumStripe->note);
        xml.setAttribute (objectName+"volume", drumStripe->volume);
        xml.setAttribute (objectName+"balance", drumStripe->balance);
        xml.setAttribute (objectName+"pitch", drumStripe->pitch);
        xml.setAttribute (objectName+"attack", drumStripe->attack);
        xml.setAttribute (objectName+"decay", drumStripe->decay);
        xml.setAttribute (objectName+"outputSelected", drumStripe->outputSelected);
        debugLog((juce::String) drumStripe->outputSelected);
    }
    
    String controlBindingStr;
    for (auto it=controlBindingMap.begin(); it!=controlBindingMap.end(); ++it){
        controlBindingStr+=(String)it->first+";"+it->second+"|";
    }
    xml.setAttribute("controlBindingStr", controlBindingStr);
    
    // then use this helper function to stuff it into the binary blob and return it..
    copyXmlToBinary (xml, destData);
}

void JuceDemoPluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    debugLog((String) __FUNCTION__, true );
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.

    // This getXmlFromBinary() helper function retrieves our XML from the binary blob..
    ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));

    if (xmlState != nullptr)
    {
        // make sure that it's actually our type of XML object..
        if (xmlState->hasTagName ("MYPLUGINSETTINGS"))
        {
            // ok, now pull out our parameters..
            lastUIWidth  = xmlState->getIntAttribute ("uiWidth", lastUIWidth);
            lastUIHeight = xmlState->getIntAttribute ("uiHeight", lastUIHeight);

            gain->setValue (xmlState->getDoubleAttribute ("gain", gain->getValue()));
            delay->setValue (xmlState->getDoubleAttribute ("delay", delay->getValue()));
            
            for (auto & drumStripe : drumStripes) {
                String objectName = "drumStripe" +(String)drumStripe->position +"_";
                //info="load "+ xmlState->getStringAttribute(objectName+"samplesPath",drumStripe->samplesPath);
                drumStripe->samplesPath = xmlState->getStringAttribute(objectName+"samplesPath",drumStripe->samplesPath);
                drumStripe->soundIndex = xmlState->getIntAttribute(objectName+"soundIndex",drumStripe->soundIndex);
                drumStripe->forcedSoundIndex = xmlState->getIntAttribute(objectName+"soundIndex",drumStripe->soundIndex);
                drumStripe->playMode = xmlState->getIntAttribute(objectName+"playMode",drumStripe->playMode);
                drumStripe->reverse = xmlState->getIntAttribute(objectName+"reverse",drumStripe->reverse);
                drumStripe->note = xmlState->getIntAttribute(objectName+"note",drumStripe->note);
                drumStripe->volume = xmlState->getDoubleAttribute(objectName+"volume",drumStripe->volume);
                drumStripe->balance = xmlState->getDoubleAttribute(objectName+"balance",drumStripe->balance);
                drumStripe->pitch = xmlState->getDoubleAttribute(objectName+"pitch",drumStripe->pitch);
                drumStripe->attack = xmlState->getDoubleAttribute(objectName+"attack",drumStripe->attack);
                drumStripe->decay = xmlState->getDoubleAttribute(objectName+"decay",drumStripe->decay);
                drumStripe->outputSelected = xmlState->getIntAttribute(objectName+"outputSelected",drumStripe->outputSelected);
                //Refresh stripe with loaded params
                drumStripe->outputDropDown.setSelectedId(drumStripe->outputSelected);
                drumStripe->updateDirectoryContentList();
            }
            
            String controlBindingStr = xmlState->getStringAttribute("controlBindingStr","");
            StringArray cBindingList;
            cBindingList.addTokens(controlBindingStr, "|","");
            for (int i=0; i<cBindingList.size(); i++)
            {
                StringArray bindLine;
                bindLine.addTokens(cBindingList[i], ";","");
                controlBindingMap[bindLine[0].getIntValue()]=bindLine[1];
            }
        }
    }
}


void JuceDemoPluginAudioProcessor::resetSlidersColour(){
    for (auto & drumStripe : drumStripes) {
        drumStripe->resetSlidersColour();
    }
}

const String JuceDemoPluginAudioProcessor::getInputChannelName (const int channelIndex) const
{
    return String (channelIndex + 1);
}

const String JuceDemoPluginAudioProcessor::getOutputChannelName (const int channelIndex) const
{
    return String (channelIndex + 1);
}

bool JuceDemoPluginAudioProcessor::isInputChannelStereoPair (int /*index*/) const
{
    return true;
}

bool JuceDemoPluginAudioProcessor::isOutputChannelStereoPair (int /*index*/) const
{
    return true;
}

bool JuceDemoPluginAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool JuceDemoPluginAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool JuceDemoPluginAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double JuceDemoPluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}



//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new JuceDemoPluginAudioProcessor();
}


