/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "DrumStripeHandler.h"

//==============================================================================
JuceDemoPluginAudioProcessorEditor::JuceDemoPluginAudioProcessorEditor (JuceDemoPluginAudioProcessor& owner)
    : AudioProcessorEditor (owner),
      midiKeyboard (owner.keyboardState, MidiKeyboardComponent::horizontalKeyboard),
      infoLabel (String::empty),
      gainLabel ("", "Throughput level:"),
      delayLabel ("", "Delay:"),
      balanceLabel ("", "Balance:"),
      rmsR_Label (String::empty),
      rmsL_Label (String::empty),
      gainSlider ("gain"),
      balanceSlider ("balance"),
      delaySlider ("delay"),
      thread("Directory Contents Scanning Thread"),
      directoryContentsList(nullptr, thread)
     // fDeviceManager(deviceManager)
{
    //fDeviceManager.initialise(2,2,nullptr,true);
    
    //DrumStripeHandler *editor = new  DrumStripeHandler(this);
    
    //editor = new DrumStripeHandler(this);
    
    String samplesPath ="/Users/oliou/Library/Audio/Plug-Ins/VST/GroovOliouRes/";
    
    //directoryContentsList.setDirectory (samplesPath, true, true);
    thread.startThread();
    
    //JuceDemoPluginAudioProcessor& ourProcessor = getProcessor();
    //ourProcessor.addVoices(this);
   
   // drumStripes.push_back(new DrumStripeHandler(*this,samplesPath,0,36));
   // drumStripes.push_back(new DrumStripeHandler(this,samplesPath,1,37));
   // drumStripes.push_back(new DrumStripeHandler(this,samplesPath,2,38));
    
    this->setDrumStripeEditor();
    
        // add some sliders..
    addAndMakeVisible (gainSlider);
    gainSlider.setSliderStyle (Slider::Rotary);
    gainSlider.addListener (this);
    gainSlider.setRange (0.0, 1.0, 0.01);
    
    // add some sliders..
    addAndMakeVisible (balanceSlider);
    balanceSlider.setSliderStyle (Slider::LinearHorizontal);
    balanceSlider.addListener (this);
    balanceSlider.setRange(-1.0, 1.0, 0.01);
                        
    addAndMakeVisible (delaySlider);
    delaySlider.setSliderStyle (Slider::Rotary);
    delaySlider.addListener (this);
    delaySlider.setRange (0.0, 1.0, 0.01);

    // add some labels for the sliders..
    gainLabel.attachToComponent (&gainSlider, false);
    gainLabel.setFont (Font (11.0f));

    // add some labels for the sliders..
    balanceLabel.attachToComponent (&balanceSlider, false);
    balanceLabel.setFont (Font (11.0f));
    
    delayLabel.attachToComponent (&delaySlider, false);
    delayLabel.setFont (Font (11.0f));

    // add the midi keyboard component..
    addAndMakeVisible (midiKeyboard);

    // add a label that will display the current timecode and status..
    addAndMakeVisible (infoLabel);
    infoLabel.setColour (Label::textColourId, Colours::blue);
    
    // add a label that will display the current timecode and status..
    addAndMakeVisible (rmsR_Label);
    rmsR_Label.setColour (Label::textColourId, Colours::red);
    
    // add a label that will display the current timecode and status..
    addAndMakeVisible (rmsL_Label);
    rmsL_Label.setColour (Label::textColourId, Colours::green);

    // add the triangular resizer component for the bottom-right of the UI
    addAndMakeVisible (resizer = new ResizableCornerComponent (this, &resizeLimits));
    resizeLimits.setSizeLimits (150, 150, 800, 600);


    // set our component's initial size to be the last one that was stored in the filter's settings
    //setSize (owner.lastUIWidth,
    //         owner.lastUIHeight);
    setSize (1000, 800);
    startTimer (100);
    
}

JuceDemoPluginAudioProcessorEditor::~JuceDemoPluginAudioProcessorEditor()
{
}

//==============================================================================
void JuceDemoPluginAudioProcessorEditor::paint (Graphics& g)
{
    g.setGradientFill (ColourGradient (Colours::white, 0, 0,
                                       Colours::grey, 0, (float) getHeight(), false));
    g.fillAll();
}

void JuceDemoPluginAudioProcessorEditor::setDrumStripeEditor(){
    for (auto & drumStripe : getProcessor().drumStripes) {
        drumStripe->setEditor(this);
    }
}

void JuceDemoPluginAudioProcessorEditor::refreshDrumStripeView(){
    for (auto & drumStripe : getProcessor().drumStripes) {
        drumStripe->refreshView();
    }
}

void JuceDemoPluginAudioProcessorEditor::resized()
{
    
    
    //infoLabel.setText("tesssssst", dontSendNotification);
    infoLabel.setBounds (10, 10, 900, 25);
//    
//    rmsR_Label.setBounds (10, 220, 400, 25);
//    rmsL_Label.setBounds (10, 240, 400, 25);
////    
//    gainSlider.setBounds (20, 60, 150, 40);
//    balanceSlider.setBounds (20, 110, 150, 30);
//    delaySlider.setBounds (200, 60, 150, 40);
//
//    const int keyboardHeight = 70;
//    //midiKeyboard.setBounds (4, getHeight() - keyboardHeight - 4, getWidth() - 8, keyboardHeight);
//
//
//    resizer->setBounds (getWidth() - 16, getHeight() - 16, 16, 16);

    getProcessor().lastUIWidth = getWidth();
    getProcessor().lastUIHeight = getHeight();

//    String samplesPath ="/Users/oliou/Library/Audio/Plug-Ins/VST/GroovOliouRes/1";
//    //String samplesPath ="GroovOliouRes/1";
//    
//    directoryContentsList.setDirectory (samplesPath, true, true);
//    thread.startThread();
    
    
  //  drumStripes[1]->resized();
  //  drumStripes[2]->resized();
    
    this->refreshDrumStripeView();
}

//==============================================================================
// This timer periodically checks whether any of the filter's parameters have changed...
void JuceDemoPluginAudioProcessorEditor::timerCallback()
{
    JuceDemoPluginAudioProcessor& ourProcessor = getProcessor();

    AudioPlayHead::CurrentPositionInfo newPos (ourProcessor.lastPosInfo);

    if (lastDisplayedPosition != newPos)
        displayPositionInfo (newPos);

    gainSlider.setValue (ourProcessor.gain->getValue(), dontSendNotification);
    delaySlider.setValue (ourProcessor.delay->getValue(), dontSendNotification);
    balanceSlider.setValue (ourProcessor.balance->getValue(), dontSendNotification);
    
    
//    infoLabel.setText (infoLabel.getText().substring(50, 200) + (String) ourProcessor.info,dontSendNotification);
//    if(infoLabel.getText().length() > 200 ) {
////        ourProcessor.info=" # " + infoLabel.getText().substring(50, 200);
//        infoLabel.setText ("",dontSendNotification);
//    }
    infoLabel.setText((String) ourProcessor.info,dontSendNotification);
    
    rmsR_Label.setText (rmsR_Label.getText() + (String) ourProcessor.rmsR,dontSendNotification);
    if(rmsR_Label.getText().length() > 100 ) {
        rmsR_Label.setText ("R: ",dontSendNotification);
    }
    rmsL_Label.setText (rmsL_Label.getText() + (String) ourProcessor.rmsL,dontSendNotification);
    if(rmsL_Label.getText().length() > 100 ) {
        rmsL_Label.setText ("L: ",dontSendNotification);
    }
    
    //getProcesser().
    
//    thread.startThread();
//    infoLabel.setText( (String) directoryContentsList.getNumFiles() ,dontSendNotification);
//    infoLabel.setText( infoLabel.getText() + "|" +(String) directoryContentsList.isStillLoading() ,dontSendNotification);
//    File file = directoryContentsList.getFile(1);
//    infoLabel.setText( infoLabel.getText() + "|" +(String) file.getFileName(),dontSendNotification);
}

void JuceDemoPluginAudioProcessorEditor::setInfoMessage(String message, bool append)
{
    if(!append){
        infoLabel.setText(message, dontSendNotification);
    }else{
        infoLabel.setText(infoLabel.getText() + message, dontSendNotification);
    }
}

String JuceDemoPluginAudioProcessorEditor::getInfoMessage()
{
    return infoLabel.getText();
}

// This is our Slider::Listener callback, when the user drags a slider.
void JuceDemoPluginAudioProcessorEditor::sliderValueChanged (Slider* slider)
{
    if (AudioProcessorParameter* param = getParameterFromSlider (slider))
    {
        // It's vital to use setValueNotifyingHost to change any parameters that are automatable
        // by the host, rather than just modifying them directly, otherwise the host won't know
        // that they've changed.
        param->setValueNotifyingHost ((float) slider->getValue());
    }
}

void JuceDemoPluginAudioProcessorEditor::sliderDragStarted (Slider* slider)
{
    if (AudioProcessorParameter* param = getParameterFromSlider (slider))
    {
        param->beginChangeGesture();
    }
}

void JuceDemoPluginAudioProcessorEditor::sliderDragEnded (Slider* slider)
{
    if (AudioProcessorParameter* param = getParameterFromSlider (slider))
    {
        param->endChangeGesture();
    }
}

//==============================================================================
// quick-and-dirty function to format a timecode string
static String timeToTimecodeString (const double seconds)
{
    const double absSecs = std::abs (seconds);

    const int hours =  (int) (absSecs / (60.0 * 60.0));
    const int mins  = ((int) (absSecs / 60.0)) % 60;
    const int secs  = ((int) absSecs) % 60;

    String s (seconds < 0 ? "-" : "");

    s << String (hours).paddedLeft ('0', 2) << ":"
      << String (mins) .paddedLeft ('0', 2) << ":"
      << String (secs) .paddedLeft ('0', 2) << ":"
      << String (roundToInt (absSecs * 1000) % 1000).paddedLeft ('0', 3);

    return s;
}

// quick-and-dirty function to format a bars/beats string
static String ppqToBarsBeatsString (double ppq, double /*lastBarPPQ*/, int numerator, int denominator)
{
    if (numerator == 0 || denominator == 0)
        return "1|1|0";

    const int ppqPerBar = (numerator * 4 / denominator);
    const double beats  = (fmod (ppq, ppqPerBar) / ppqPerBar) * numerator;

    const int bar    = ((int) ppq) / ppqPerBar + 1;
    const int beat   = ((int) beats) + 1;
    const int ticks  = ((int) (fmod (beats, 1.0) * 960.0 + 0.5));

    String s;
    s << bar << '|' << beat << '|' << ticks;
    return s;
}

AudioProcessorParameter* JuceDemoPluginAudioProcessorEditor::getParameterFromSlider (const Slider* slider) const
{
    if (slider == &gainSlider)
        return getProcessor().gain;
    
    if (slider == &balanceSlider)
        return getProcessor().balance;

    if (slider == &delaySlider)
        return getProcessor().delay;

    return nullptr;
}

// Updates the text in our position label.
void JuceDemoPluginAudioProcessorEditor::displayPositionInfo (const AudioPlayHead::CurrentPositionInfo& pos)
{
    lastDisplayedPosition = pos;
    String displayText;
    displayText.preallocateBytes (128);

    displayText << String (pos.bpm, 2) << " bpm, "
                << pos.timeSigNumerator << '/' << pos.timeSigDenominator
                << "  -  " << timeToTimecodeString (pos.timeInSeconds)
                << "  -  " << ppqToBarsBeatsString (pos.ppqPosition, pos.ppqPositionOfLastBarStart,
                                                    pos.timeSigNumerator, pos.timeSigDenominator);

    if (pos.isRecording)
        displayText << "  (recording)";
    else if (pos.isPlaying)
        displayText << "  (playing)";

//    infoLabel.setText ("[" + SystemStats::getJUCEVersion() + "]   " + displayText, dontSendNotification);
    //infoLabel.setText ("", dontSendNotification);
}
